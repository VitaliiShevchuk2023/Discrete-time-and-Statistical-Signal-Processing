


### Задача 1.7 (Інверсний сигнал)

Нехай
f[k] = {
  1, якщо k ∈ {0,1},
  0, в інших випадках.
}

Скільки існує дійсних дискретно-часових сигналів g[·] таких, що (g * f)[·] = δ[·]? Вкажіть (якщо можливо) три такі сигнали g[·].

Для розв'язання цієї задачі потрібно:
1) Зрозуміти, що таке інверсний сигнал.
2) Застосувати формулу згортки для знаходження можливих сигналів g[·].

Інверсний сигнал δ[·] - це одиничний імпульс, який визначається як:
δ[k] = {
  1, якщо k = 0,
  0, в інших випадках.
}

Формула згортки: (g * f)[k] = Σ g[n]f[k-n]

Підставляючи дані, отримаємо:
(g * f)[0] = g[0]f[0] + g[1]f[-1] = g[0]
(g * f)[1] = g[0]f[1] + g[1]f[0] = g[1] + g[0]
(g * f)[k] = 0 для k ≠ 0, 1

Щоб (g * f)[·] = δ[·], маємо:
(g * f)[0] = 1
(g * f)[1] = 0
(g * f)[k] = 0 для k ≠ 0, 1

Отже, умови задовольняються, якщо:
g[0] = 1
g[1] = -1
g[k] = 0 для k ≠ 0, 1

Таким чином, три можливі сигнали g[·] є:
g[·] = {1, -1, 0, 0, 0, ...}
g[·] = {0, 1, -1, 0, 0, ...}
g[·] = {0, 0, 1, -1, 0, ...}



### Приклад на Python

Задача передбачає знаходження сигналів \( g[k] \), які при згортці з \( f[k] \) дадуть одиничний імпульс \( \delta[k] \). Нам необхідно перевірити, чи обрані сигнали \( g[k] \) задовольняють умови задачі, тобто \( (g * f)[0] = 1 \) та \( (g * f)[1] = 0 \) для кожного з трьох прикладів сигналів \( g[k] \).

Ось Python-код, який демонструє цей розрахунок:

```python
import numpy as np

# Заданий сигнал f[k]
f = [1, 1]  # Значення f[k]: f[0] = 1, f[1] = 1, а інші елементи дорівнюють 0

# Три можливі варіанти g[k]
g1 = [1, -1, 0, 0, 0]      # g[·] = {1, -1, 0, 0, 0, ...}
g2 = [0, 1, -1, 0, 0]       # g[·] = {0, 1, -1, 0, 0, ...}
g3 = [0, 0, 1, -1, 0]       # g[·] = {0, 0, 1, -1, 0, ...}

# Виконуємо згортку для кожного сигналу g[k] з f[k] і перевіряємо результат
y1 = np.convolve(g1, f, mode='full')
y2 = np.convolve(g2, f, mode='full')
y3 = np.convolve(g3, f, mode='full')

# Виведення результатів
print("Згортка (g1 * f):", y1)
print("Згортка (g2 * f):", y2)
print("Згортка (g3 * f):", y3)

# Перевірка, чи дорівнюють результати одиничному імпульсу δ[k]
delta = [1] + [0] * (len(y1) - 1)
print("\nПеревірка на одиничний імпульс δ[k]:")
print("Чи відповідає y1 δ[k]? -", np.array_equal(y1, delta))
print("Чи відповідає y2 δ[k]? -", np.array_equal(y2, delta))
print("Чи відповідає y3 δ[k]? -", np.array_equal(y3, delta))
```

### Пояснення коду

1. **Сигнал \( f[k] \)**: Представлений як масив `[1, 1]`, що відповідає умові \( f[0] = 1 \) та \( f[1] = 1 \).
2. **Сигнали \( g[k] \)**: Ми визначаємо три можливі сигнали \( g[k] \), які можуть дати одиничний імпульс при згортці з \( f[k] \).
3. **Згортка**: Виконуємо згортку кожного з сигналів \( g[k] \) з \( f[k] \), використовуючи `np.convolve`.
4. **Перевірка на одиничний імпульс**: Перевіряємо, чи результат згортки дорівнює одиничному імпульсу \( \delta[k] \), для цього порівнюємо отриману згортку з ідеальним результатом `[1, 0, 0, ...]`.

### Очікуваний результат
Кожна з трьох згорток повинна відповідати одиничному імпульсу, отже, всі три варіанти \( g[k] \) задовольняють умову задачі.
