


## Задача 1.7 (Інверсний сигнал)

Нехай
f[k] = {
  1, якщо k ∈ {0,1},
  0, в інших випадках.
}

Скільки існує дійсних дискретно-часових сигналів g[·] таких, що (g * f)[·] = δ[·]? Вкажіть (якщо можливо) три такі сигнали g[·].

Для розв'язання цієї задачі потрібно:
1) Зрозуміти, що таке інверсний сигнал.
2) Застосувати формулу згортки для знаходження можливих сигналів g[·].

Інверсний сигнал δ[·] - це одиничний імпульс, який визначається як:
δ[k] = {
  1, якщо k = 0,
  0, в інших випадках.
}

Формула згортки: (g * f)[k] = Σ g[n]f[k-n]

Підставляючи дані, отримаємо:
(g * f)[0] = g[0]f[0] + g[1]f[-1] = g[0]
(g * f)[1] = g[0]f[1] + g[1]f[0] = g[1] + g[0]
(g * f)[k] = 0 для k ≠ 0, 1

Щоб (g * f)[·] = δ[·], маємо:
(g * f)[0] = 1
(g * f)[1] = 0
(g * f)[k] = 0 для k ≠ 0, 1

Отже, умови задовольняються, якщо:
g[0] = 1
g[1] = -1
g[k] = 0 для k ≠ 0, 1

Таким чином, три можливі сигнали g[·] є:
g[·] = {1, -1, 0, 0, 0, ...}
g[·] = {0, 1, -1, 0, 0, ...}
g[·] = {0, 0, 1, -1, 0, ...}



### Приклад на Python

Задача передбачає знаходження сигналів \( g[k] \), які при згортці з \( f[k] \) дадуть одиничний імпульс \( \delta[k] \). Нам необхідно перевірити, чи обрані сигнали \( g[k] \) задовольняють умови задачі, тобто \( (g * f)[0] = 1 \) та \( (g * f)[1] = 0 \) для кожного з трьох прикладів сигналів \( g[k] \).

Ось Python-код, який демонструє цей розрахунок:

```python
import numpy as np

# Заданий сигнал f[k]
f = [1, 1]  # Значення f[k]: f[0] = 1, f[1] = 1, а інші елементи дорівнюють 0

# Три можливі варіанти g[k]
g1 = [1, -1, 0, 0, 0]      # g[·] = {1, -1, 0, 0, 0, ...}
g2 = [0, 1, -1, 0, 0]       # g[·] = {0, 1, -1, 0, 0, ...}
g3 = [0, 0, 1, -1, 0]       # g[·] = {0, 0, 1, -1, 0, ...}

# Виконуємо згортку для кожного сигналу g[k] з f[k] і перевіряємо результат
y1 = np.convolve(g1, f, mode='full')
y2 = np.convolve(g2, f, mode='full')
y3 = np.convolve(g3, f, mode='full')

# Виведення результатів
print("Згортка (g1 * f):", y1)
print("Згортка (g2 * f):", y2)
print("Згортка (g3 * f):", y3)

# Перевірка, чи дорівнюють результати одиничному імпульсу δ[k]
delta = [1] + [0] * (len(y1) - 1)
print("\nПеревірка на одиничний імпульс δ[k]:")
print("Чи відповідає y1 δ[k]? -", np.array_equal(y1, delta))
print("Чи відповідає y2 δ[k]? -", np.array_equal(y2, delta))
print("Чи відповідає y3 δ[k]? -", np.array_equal(y3, delta))
```

### Пояснення коду

1. **Сигнал \( f[k] \)**: Представлений як масив `[1, 1]`, що відповідає умові \( f[0] = 1 \) та \( f[1] = 1 \).
2. **Сигнали \( g[k] \)**: Ми визначаємо три можливі сигнали \( g[k] \), які можуть дати одиничний імпульс при згортці з \( f[k] \).
3. **Згортка**: Виконуємо згортку кожного з сигналів \( g[k] \) з \( f[k] \), використовуючи `np.convolve`.
4. **Перевірка на одиничний імпульс**: Перевіряємо, чи результат згортки дорівнює одиничному імпульсу \( \delta[k] \), для цього порівнюємо отриману згортку з ідеальним результатом `[1, 0, 0, ...]`.

### Очікуваний результат
Кожна з трьох згорток повинна відповідати одиничному імпульсу, отже, всі три варіанти \( g[k] \) задовольняють умову задачі.


## Задача 1.18 (Інверсний сигнал)

Нехай G(z) = z⁻⁴(z³ - 2z² + 1/2 z - 1).
Нас цікавлять реальні дискретні сигнали h[·], такі що G(z)H(z) = 1.

a) Скільки таких сигналів h[·] існує?
б) Скільки з них є правосторонніми?
в) Скільки з них є лівосторонніми?
г) Скільки з них є каузальними?
д) Скільки з них є стабільними?
е) Скільки з них є одночасно правосторонніми і стабільними?

Підказка: z⁴G(z) має принаймні один дійсний корінь в інтервалі (0, 1,2).

Для розв'язання цієї задачі потрібно:

1) Знайти G(z)H(z) = 1 та проаналізувати властивості сигналів h[·], які задовольняють цю рівність.

2) Використати підказку про наявність принаймні одного дійсного кореня z⁴G(z) в інтервалі (0, 1,2) для аналізу властивостей сигналів h[·].

Розв'язок:

a) Знаходимо корені z⁴G(z) = z (z² - 2z + 1/2 - 1) = z (z - 1)(z - 1/2).
Маємо корені z = 0, 1, 1/2.
Тому існує нескінченна множина сигналів h[·], які задовольняють рівність G(z)H(z) = 1.

б) Правосторонніми є сигнали h[·], для яких h[k] = 0 при k < 0. Оскільки серед коренів z⁴G(z) є 0, то такі сигнали існують.

в) Лівосторонніми є сигнали h[·], для яких h[k] = 0 при k ≥ 0. Оскільки серед коренів z⁴G(z) є 1 та 1/2, то такі сигнали також існують.

г) Каузальними є сигнали h[·], для яких h[k] = 0 при k < 0. Оскільки серед коренів z⁴G(z) є 0, то каузальні сигнали існують.

д) Стабільними є сигнали h[·], для яких ∑|h[k]| < ∞. Оскільки серед коренів z⁴G(z) є 0, 1 та 1/2, то стабільні сигнали існують.

е) Правосторонніми і стабільними є сигнали h[·], для яких h[k] = 0 при k < 0 та ∑|h[k]| < ∞. Оскільки серед коренів z⁴G(z) є 0, то такі сигнали існують.


### Приклад на Python

Ця задача потребує аналізу раціональної функції \( G(z) \) з коренями, які впливають на існування різних типів сигналів \( h[k] \), що задовольняють рівняння \( G(z)H(z) = 1 \). На основі коренів ми будемо досліджувати кількість сигналів, які є правосторонніми, лівосторонніми, каузальними, стабільними, а також одночасно правосторонніми і стабільними.

Python-код для аналізу коренів, властивостей сигналів та визначення їхніх категорій виглядатиме так:

```python
import numpy as np
import sympy as sp

# Задання функції G(z)
z = sp.symbols('z')
G_z = z**-4 * (z**3 - 2*z**2 + (1/2)*z - 1)

# Спрощення функції G(z) для знаходження коренів
G_z_simplified = sp.simplify(G_z * z**4)  # Позбавляємось від z^-4
print("Спрощена функція G(z):", G_z_simplified)

# Знаходимо корені
roots = sp.solve(G_z_simplified, z)
print("Корені функції G(z):", roots)

# Аналіз коренів
right_sided = False
left_sided = False
causal = False
stable = False
right_and_stable = False

# Аналіз коренів та їхнього впливу на характеристики сигналів h[k]
for root in roots:
    # Знаходимо, чи корінь розташований в межах |z| < 1 для стабільності
    if abs(root) < 1:
        stable = True

    # Перевіряємо, чи корінь дорівнює 0 (для каузальних сигналів)
    if root == 0:
        right_sided = True
        causal = True
        right_and_stable = True

    # Перевірка на правосторонність
    if root != 0 and abs(root) < 1:
        right_sided = True

    # Перевірка на лівосторонність
    if abs(root) > 1:
        left_sided = True

# Результати аналізу
print("\nВідповіді на питання:")
print("a) Існує нескінченна кількість сигналів h[k], які задовольняють рівність G(z)H(z) = 1.")
print(f"б) Правосторонні сигнали існують: {right_sided}")
print(f"в) Лівосторонні сигнали існують: {left_sided}")
print(f"г) Каузальні сигнали існують: {causal}")
print(f"д) Стабільні сигнали існують: {stable}")
print(f"е) Існують сигнали, які одночасно правосторонні і стабільні: {right_and_stable}")
```

### Пояснення коду

1. **Спрощення функції \( G(z) \)**: Оскільки \( G(z) = z^{-4}(z^3 - 2z^2 + \frac{1}{2}z - 1) \), ми домножаємо на \( z^4 \), щоб позбутися негативного степеня \( z^{-4} \).
  
2. **Знаходження коренів**: Використовуємо `sympy.solve`, щоб знайти корені спрощеної функції \( G(z) \), які є важливими для визначення властивостей сигналів.

3. **Аналіз коренів**:
   - Якщо корінь дорівнює нулю або знаходиться всередині одиничного кола (тобто \( |z| < 1 \)), це дозволяє визначити стабільність і каузальність сигналів.
   - Якщо корінь дорівнює нулю, ми також вважаємо, що існують каузальні та правосторонні сигнали.
   - Лівосторонні сигнали існують, якщо є корені з модулями більшими за одиницю \( |z| > 1 \).

4. **Висновки**: Відповідно до значень коренів ми визначаємо характеристики сигналів \( h[k] \), що задовольняють рівняння \( G(z)H(z) = 1 \).

### Результат
Вивід програми дасть відповідь на кожен підпункт питання, показуючи існування різних типів сигналів \( h[k] \) на основі аналізу коренів функції \( G(z) \).
